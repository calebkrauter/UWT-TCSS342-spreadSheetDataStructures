Index: model/Spreadsheet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\nimport java.beans.PropertyChangeListener;\r\nimport java.beans.PropertyChangeSupport;\r\nimport java.util.Stack;\r\n\r\n@SuppressWarnings(\"SpellCheckingInspection\")\r\npublic class Spreadsheet implements PropertyChangeEnabledSpreadSheet {\r\n    \r\n    private static int rows;\r\n    \r\n    private static int cols;\r\n    static private Cell[][] cellArray;\r\n\t\r\n\t/** The property change support. */\r\n\tprivate final PropertyChangeSupport myPcs = new PropertyChangeSupport(Spreadsheet.class);\r\n    \r\n    public Spreadsheet(int rowSize, int columnSize) {\r\n        rows = rowSize;\r\n        cols = columnSize;\r\n        \r\n        cellArray = new Cell[rows][cols];\r\n        for (int r = 0; r < rows; r++) {\r\n        \tfor (int c = 0; c < cols; c++) {\r\n        \t\tcellArray[r][c] = new Cell();\r\n        \t}\r\n        }\r\n    }\r\n    \r\n    public int getNumColumns() {\r\n        return cols;\r\n    }\r\n    \r\n    public int getNumRows() {\r\n        return rows;\r\n    }\r\n    \r\n    public Cell getCell(int row, int column) {\r\n        return cellArray[row][column];\r\n    }\r\n    \r\n    public int getCellValue(CellToken cellToken) {\r\n    \treturn cellArray[cellToken.getRow()][cellToken.getColumn()].getValue();\r\n    }\r\n    \r\n    public void changeCellFormulaAndRecalculate(CellToken cellToken, String s) {\r\n    \tCell c = cellArray[cellToken.getRow()][cellToken.getColumn()];\r\n    \t// dereferences itself from dependents first\r\n    \t// useful for when the user changes the formula\r\n    \tif (c.getDependents() != null) {\r\n    \t\tfor (CellToken ct: c.getDependents()) {\r\n    \t\t\tcellArray[ct.getRow()][ct.getColumn()].removeReferences(c);\r\n    \t\t}\r\n    \t}\r\n    \tString prevFormula = c.getFormula();\r\n    \tc.setFormula(s);\r\n    \t// goes through the cells that it is dependent on and reference itself on them\r\n    \tif (c.getDependents() != null) {\r\n    \t\tfor (CellToken ct: c.getDependents()) {\r\n    \t\t\tcellArray[ct.getRow()][ct.getColumn()].addReferences(c);\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \t// copies all the indegrees to pass into the topological sort\r\n    \tint[][] indegrees = new int[rows][cols];\r\n    \tfor (int row = 0; row < rows; row++) {\r\n    \t\tfor (int col = 0; col < cols; col++) {\r\n        \t\tif(cellArray[row][col].hasFormula())\r\n                    indegrees[row][col] = cellArray[row][col].getIndegrees();\r\n        \t}\r\n    \t}\r\n    \t\r\n    \t// sorts the cells and puts it in a stack to evaluate the cells in correct order\r\n    \tStack<Cell> ts = TopologicalSort.sort(cellArray, indegrees);\r\n    \tif (ts == null) { // cycle found\r\n\t\t\tchangeCellFormulaAndRecalculate(cellToken, prevFormula);\r\n\t\t\tmyPcs.firePropertyChange(PROPERTY_CYCLE, 0, cellToken);\r\n    \t} else {\r\n    \t\twhile (!ts.isEmpty()) {\r\n        \t\tts.peek().evaluate(this);\r\n        \t\tfor (Cell r : ts.pop().getReferences()) {\r\n        \t\t\tr.evaluate(this);\r\n        \t\t}\r\n        \t}\r\n    \t}\r\n    }\r\n\t\r\n\t/**\r\n\t * Adds a property change listener.\r\n\t *\r\n\t * @param theListener the listener\r\n\t */\r\n\t@Override\r\n\tpublic void addPropertyChangeListener(final PropertyChangeListener theListener) {\r\n\t\tmyPcs.addPropertyChangeListener(theListener);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Adds a property change listener.\r\n\t *\r\n\t * @param thePropertyName the property name\r\n\t * @param theListener the listener\r\n\t */\r\n\t@Override\r\n\tpublic void addPropertyChangeListener(final String thePropertyName,\r\n\t\t\t\t\t\t\t\t\t\t  final PropertyChangeListener theListener) {\r\n\t\tmyPcs.addPropertyChangeListener(thePropertyName, theListener);\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Removes a property change listener.\r\n\t *\r\n\t * @param theListener the listener\r\n\t */\r\n\t@Override\r\n\tpublic void removePropertyChangeListener(final PropertyChangeListener theListener) {\r\n\t\tmyPcs.removePropertyChangeListener(theListener);\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Removes a property change listener.\r\n\t *\r\n\t * @param thePropertyName the property name\r\n\t * @param theListener the listener\r\n\t */\r\n\t@Override\r\n\tpublic void removePropertyChangeListener(final String thePropertyName,\r\n\t\t\t\t\t\t\t\t\t\t\t final PropertyChangeListener theListener) {\r\n\t\tmyPcs.removePropertyChangeListener(thePropertyName, theListener);\r\n\t\t\r\n\t}\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/Spreadsheet.java b/model/Spreadsheet.java
--- a/model/Spreadsheet.java	
+++ b/model/Spreadsheet.java	
@@ -1,21 +1,41 @@
+/**
+ * @author Bairu Li
+ * @author Andy Comfort
+ */
 package model;
 
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeSupport;
+import java.util.LinkedList;
+import java.util.Queue;
 import java.util.Stack;
 
-@SuppressWarnings("SpellCheckingInspection")
+/**
+ * Represents a spreadsheet of interactive cells
+ * that has the ability to represent basic mathematical
+ * formulas.
+ */
 public class Spreadsheet implements PropertyChangeEnabledSpreadSheet {
-    
+	
+	/** The number of rows in this spreadsheet. */
     private static int rows;
-    
+	
+	/** The number of columns in this spreadsheet. */
     private static int cols;
+	
+	/** The array of cells representing this spreadsheet. */
     static private Cell[][] cellArray;
 	
 	/** The property change support. */
 	private final PropertyChangeSupport myPcs = new PropertyChangeSupport(Spreadsheet.class);
-    
-    public Spreadsheet(int rowSize, int columnSize) {
+	
+	/**
+	 * Instantiates a new Spreadsheet.
+	 *
+	 * @param rowSize    the row size
+	 * @param columnSize the column size
+	 */
+	public Spreadsheet(int rowSize, int columnSize) {
         rows = rowSize;
         cols = columnSize;
         
@@ -26,24 +46,53 @@
         	}
         }
     }
-    
-    public int getNumColumns() {
+	
+	/**
+	 * Gets the number of columns.
+	 *
+	 * @return the number of columns
+	 */
+	public int getNumColumns() {
         return cols;
     }
-    
-    public int getNumRows() {
+	
+	/**
+	 * Gets the number of rows.
+	 *
+	 * @return the number of rows
+	 */
+	public int getNumRows() {
         return rows;
     }
-    
-    public Cell getCell(int row, int column) {
+	
+	/**
+	 * Gets a cell based on row and column.
+	 *
+	 * @param row    the row of the cell
+	 * @param column the column of the cell
+	 * @return the cell
+	 */
+	public Cell getCell(int row, int column) {
         return cellArray[row][column];
     }
-    
-    public int getCellValue(CellToken cellToken) {
+	
+	/**
+	 * Gets a cell value.
+	 *
+	 * @param cellToken the cell token
+	 * @return the cell value
+	 */
+	public int getCellValue(CellToken cellToken) {
     	return cellArray[cellToken.getRow()][cellToken.getColumn()].getValue();
     }
-    
-    public void changeCellFormulaAndRecalculate(CellToken cellToken, String s) {
+	
+	/**
+	 * Changes a cell formula and recalculates the spreadsheet.
+	 *
+	 * @param cellToken  the cell token
+	 * @param newFormula the newFormula
+	 */
+	public void changeCellFormulaAndRecalculate(CellToken cellToken, String newFormula) {
     	Cell c = cellArray[cellToken.getRow()][cellToken.getColumn()];
     	// dereferences itself from dependents first
     	// useful for when the user changes the formula
@@ -52,8 +101,9 @@
     			cellArray[ct.getRow()][ct.getColumn()].removeReferences(c);
     		}
     	}
+		// saves previous formula in case of a cycle
     	String prevFormula = c.getFormula();
-    	c.setFormula(s);
+    	c.setFormula(newFormula);
     	// goes through the cells that it is dependent on and reference itself on them
     	if (c.getDependents() != null) {
     		for (CellToken ct: c.getDependents()) {
@@ -71,7 +121,7 @@
     	}
     	
     	// sorts the cells and puts it in a stack to evaluate the cells in correct order
-    	Stack<Cell> ts = TopologicalSort.sort(cellArray, indegrees);
+    	Stack<Cell> ts = topologicalSort(indegrees);
     	if (ts == null) { // cycle found
 			changeCellFormulaAndRecalculate(cellToken, prevFormula);
 			myPcs.firePropertyChange(PROPERTY_CYCLE, 0, cellToken);
@@ -85,6 +135,60 @@
     	}
     }
 	
+	/**
+	 * Iterates through the cell array and returns a stack
+	 * where each cell appears after all cells it points to.
+	 *
+	 * @param theIndegrees the indegrees of each cell
+	 * @return the stack of cells in topological order
+	 */
+	public static Stack<Cell> topologicalSort(final int[][] theIndegrees) {
+		Stack<Cell> s = new Stack<>();
+		Queue<Integer> q = new LinkedList<>();
+		int len = cellArray.length;
+		
+		// Add cells with 0 indegrees to the queue
+		for (int i = 0; i < len; i++) {
+			for (int j = 0; j < cellArray[i].length; j++) {
+				if (theIndegrees[i][j] == 0) {
+					q.add(i * len + j);
+				}
+			}
+		}
+		
+		while (!q.isEmpty()) {
+			int dq = q.poll();
+			Cell c = cellArray[dq / len][dq % len];
+			
+			// If the cell has no dependents, skip to the next iteration
+			if (c.getDependents() == null) {
+				continue;
+			}
+			
+			// Decrement the indegrees of the cell's dependents
+			for (final CellToken dependents : c.getDependents()) {
+				int row = dependents.getRow();
+				int col = dependents.getColumn();
+				
+				if (theIndegrees[row][col] != -1) {
+					theIndegrees[row][col]--;
+					if (theIndegrees[row][col] == 0) {
+						q.add(row * len + col);
+					}
+				}
+			}
+			
+			// Add the processed cell to the output stack
+			s.add(c);
+		}
+		
+		if (s.size() != len * cellArray[0].length) {
+			return null;
+		}
+		
+		return s;
+	}
+	
 	/**
 	 * Adds a property change listener.
 	 *
Index: model/TopologicalSort.java
===================================================================
diff --git a/model/TopologicalSort.java b/model/TopologicalSort.java
deleted file mode 100644
--- a/model/TopologicalSort.java	
+++ /dev/null	
@@ -1,57 +0,0 @@
-package model;
-
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.Stack;
-
-@SuppressWarnings("SpellCheckingInspection")
-public final class TopologicalSort {
-	private TopologicalSort() {}
-	
-	public static Stack<Cell> sort(final Cell[][] theCellArr, final int[][] theIndegrees) {
-		Stack<Cell> s = new Stack<>();
-		Queue<Integer> q = new LinkedList<>();
-		int len = theCellArr.length;
-		
-		// Add cells with 0 indegrees to the queue
-		for (int i = 0; i < len; i++) {
-			for (int j = 0; j < theCellArr[i].length; j++) {
-				if (theIndegrees[i][j] == 0) {
-					q.add(i * len + j);
-				}
-			}
-		}
-		
-		while (!q.isEmpty()) {
-			int dq = q.poll();
-			Cell c = theCellArr[dq / len][dq % len];
-			
-			// If the cell has no dependents, skip to the next iteration
-			if (c.getDependents() == null) {
-				continue;
-			}
-			
-			// Decrement the indegrees of the cell's dependents
-			for (final CellToken dependents : c.getDependents()) {
-				int row = dependents.getRow();
-				int col = dependents.getColumn();
-				
-				if (theIndegrees[row][col] != -1) {
-					theIndegrees[row][col]--;
-					if (theIndegrees[row][col] == 0) {
-						q.add(row * len + col);
-					}
-				}
-			}
-			
-			// Add the processed cell to the output stack
-			s.add(c);
-		}
-		
-		if (s.size() != len * theCellArr[0].length) {
-			return null;
-		}
-		
-		return s;
-	}
-}
Index: model/CellToken.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class CellToken extends Token {\r\n    private int column; // column A = 0, B = 1, etc.\r\n    private int row;\r\n    \r\n    public CellToken() {\r\n        super(\"CELL\");\r\n    }\r\n    \r\n    public void setColumn(int theColumn) {\r\n        column = theColumn;\r\n    }\r\n    \r\n    public void setRow(int theRow) {\r\n        row = theRow;\r\n    }\r\n    \r\n    public int getColumn() {\r\n        return column;\r\n    }\r\n    \r\n    public int getRow() {\r\n        return row;\r\n    }\r\n    \r\n    public String getValue() {\r\n        int colVal = column + 1;\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        while (colVal-- > 0) {\r\n            sb.insert(0, (char) ('A' + (colVal % 26)));\r\n            colVal /= 26;\r\n        }\r\n        sb = sb.append(row);\r\n        return sb.toString();\r\n    }\r\n    \r\n    @Override\r\n    public int hashCode() {\r\n    \treturn Objects.hash(getValue());\r\n    }\r\n    \r\n    @Override\r\n    public boolean equals(Object o) {\r\n    \tif (o.getClass() != CellToken.class)\r\n    \t\treturn false;\r\n    \tCellToken ct = (CellToken) o;\r\n    \treturn row == ct.row && column == ct.column;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/CellToken.java b/model/CellToken.java
--- a/model/CellToken.java	
+++ b/model/CellToken.java	
@@ -1,31 +1,74 @@
+/**
+ * @author Bairu Li
+ * @author Andy Comfort
+ */
 package model;
 
 import java.util.Objects;
 
+/**
+ * Represents a token of a single cell in the
+ * spreadsheet.
+ */
 public class CellToken extends Token {
+    
+    /** The column of the cell this token represents. */
     private int column; // column A = 0, B = 1, etc.
+    
+    /** The row of the cell this token represents. */
     private int row;
     
+    /**
+     * Instantiates a new Cell token.
+     */
     public CellToken() {
         super("CELL");
     }
     
+    /**
+     * Sets the column of this token.
+     *
+     * @param theColumn the column
+     */
     public void setColumn(int theColumn) {
         column = theColumn;
     }
     
+    /**
+     * Sets the row of this token.
+     *
+     * @param theRow the row
+     */
     public void setRow(int theRow) {
         row = theRow;
     }
     
+    /**
+     * Gets the column of this token.
+     *
+     * @return the column
+     */
     public int getColumn() {
         return column;
     }
     
+    /**
+     * Gets the row of this token.
+     *
+     * @return the row
+     */
     public int getRow() {
         return row;
     }
     
+    /**
+     * Gets the value of this token in the form of the
+     * column as a letter plus the row. A cell token
+     * with a column value of zero and row value of
+     * 5 would return A5.
+     *
+     * @return the value of the token.
+     */
     public String getValue() {
         int colVal = column + 1;
         
@@ -38,11 +81,22 @@
         return sb.toString();
     }
     
+    /**
+     * Generates a hash code representation of this CellToken.
+     *
+     * @return the hash code representation of this CellToken
+     */
     @Override
     public int hashCode() {
     	return Objects.hash(getValue());
     }
     
+    /**
+     * Compares this CellToken to another object to determine equality.
+     *
+     * @param o the object to compare to
+     * @return true, if items have equal row and column
+     */
     @Override
     public boolean equals(Object o) {
     	if (o.getClass() != CellToken.class)
Index: model/Cell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.Stack;\r\n\r\npublic class Cell {\r\n    \r\n    private static final int BAD_CELL = -1;\r\n    private String formula;\r\n    private int value;\r\n    // the expression tree below represents the formula\r\n    private final ExpressionTree expressionTree;\r\n    \r\n    // other cells that \"points\" to this cell\r\n    private final Set<Cell> references;\r\n    \r\n    public Cell() {\r\n        formula = \"\";\r\n        value = 0;\r\n        expressionTree = new ExpressionTree();\r\n        references = new HashSet<>();\r\n    }\r\n    \r\n    public void evaluate(Spreadsheet spreadsheet) {\r\n    \tvalue = expressionTree.evaluate(spreadsheet);\r\n    }\r\n    \r\n    public String getFormula() {\r\n        return formula;\r\n    }\r\n    \r\n    public int getValue() {\r\n    \treturn value;\r\n    }\r\n    \r\n    public boolean hasFormula() { return !formula.equals(\"\"); }\r\n    \r\n    public void addReferences(Cell c) {\r\n    \treferences.add(c);\r\n    }\r\n    \r\n    public void removeReferences(Cell c) {\r\n    \treferences.remove(c);\r\n    }\r\n    \r\n    public Cell[] getReferences() {\r\n    \treturn references.toArray(new Cell[0]);\r\n    }\r\n    \r\n    public int getIndegrees() {\r\n    \treturn references.size();\r\n    }\r\n    // gets the cells that this cell points to\r\n    public CellToken[] getDependents() {\r\n    \treturn expressionTree.getDependents().toArray(new CellToken[0]);\r\n    }\r\n    \r\n    public void setFormula(String s) {\r\n    \texpressionTree.BuildExpressionTree(getFormula(s));\r\n    \tformula = s;\r\n    \tif (s.length() == 0)\r\n    \t\tvalue = 0;\r\n    }\r\n    \r\n    /**\r\n     * getCellToken\r\n     * <p>\r\n     * Assuming that the next chars in a String (at the given startIndex)\r\n     * is a cell reference, set cellToken's column and row to the\r\n     * cell's column and row.\r\n     * If the cell reference is invalid, the row and column of the return CellToken\r\n     * are both set to BadCell (which should be a final int that equals -1).\r\n     * Also, return the index of the position in the string after processing\r\n     * the cell reference.\r\n     * (Possible improvement: instead of returning a CellToken with row and\r\n     * column equal to BadCell, throw an exception that indicates a parsing error.)\r\n     * <p>\r\n     * A cell reference is defined to be a sequence of CAPITAL letters,\r\n     * followed by a sequence of digits (0-9).  The letters refer to\r\n     * columns as follows: A = 0, B = 1, C = 2, ..., Z = 25, AA = 26,\r\n     * AB = 27, ..., AZ = 51, BA = 52, ..., ZA = 676, ..., ZZ = 701,\r\n     * AAA = 702.  The digits represent the row number.\r\n     *\r\n     * @param inputString the input string\r\n     * @param startIndex  the index of the first char to process\r\n     * @param cellToken   a cellToken (essentially a return value)\r\n     * @return index corresponding to the position in the string just after the cell reference\r\n     */\r\n    int getCellToken(String inputString, int startIndex, CellToken cellToken) {\r\n        char ch;\r\n        int column;\r\n        int row;\r\n        int index = startIndex;\r\n        \r\n        // handle a bad startIndex\r\n        if ((startIndex < 0) || (startIndex >= inputString.length())) {\r\n            cellToken.setColumn(BAD_CELL);\r\n            cellToken.setRow(BAD_CELL);\r\n            return index;\r\n        }\r\n        \r\n        // get rid of leading whitespace characters\r\n        while (index < inputString.length()) {\r\n            ch = inputString.charAt(index);\r\n            if (!Character.isWhitespace(ch)) {\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n        if (index == inputString.length()) {\r\n            // reached the end of the string before finding a capital letter\r\n            cellToken.setColumn(BAD_CELL);\r\n            cellToken.setRow(BAD_CELL);\r\n            return index;\r\n        }\r\n        \r\n        // ASSERT: index now points to the first non-whitespace character\r\n        \r\n        ch = inputString.charAt(index);\r\n        // process CAPITAL alphabetic characters to calculate the column\r\n        if (!Character.isUpperCase(ch)) {\r\n            cellToken.setColumn(BAD_CELL);\r\n            cellToken.setRow(BAD_CELL);\r\n            return index;\r\n        } else {\r\n            column = ch - 'A';\r\n            index++;\r\n        }\r\n        \r\n        while (index < inputString.length()) {\r\n            ch = inputString.charAt(index);\r\n            if (Character.isUpperCase(ch)) {\r\n                column = ((column + 1) * 26) + (ch - 'A');\r\n                index++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if (index == inputString.length()) {\r\n            // reached the end of the string before fully parsing the cell reference\r\n            cellToken.setColumn(BAD_CELL);\r\n            cellToken.setRow(BAD_CELL);\r\n            return index;\r\n        }\r\n        \r\n        // ASSERT: We have processed leading whitespace and the\r\n        // capital letters of the cell reference\r\n        \r\n        // read numeric characters to calculate the row\r\n        if (Character.isDigit(ch)) {\r\n            row = ch - '0';\r\n            index++;\r\n        } else {\r\n            cellToken.setColumn(BAD_CELL);\r\n            cellToken.setRow(BAD_CELL);\r\n            return index;\r\n        }\r\n        \r\n        while (index < inputString.length()) {\r\n            ch = inputString.charAt(index);\r\n            if (Character.isDigit(ch)) {\r\n                row = (row * 10) + (ch - '0');\r\n                index++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // successfully parsed a cell reference\r\n        cellToken.setColumn(column);\r\n        cellToken.setRow(row);\r\n        return index;\r\n    }\r\n    \r\n    /**\r\n     * getFormula\r\n     * <p>\r\n     * Given a string that represents a formula that is an infix\r\n     * expression, return a stack of Tokens so that the expression,\r\n     * when read from the bottom of the stack to the top of the stack,\r\n     * is a postfix expression.\r\n     * <p>\r\n     * A formula is defined as a sequence of tokens that represents\r\n     * a legal infix expression.\r\n     * <p>\r\n     * A token can consist of a numeric literal, a cell reference, or an\r\n     * operator (+, -, *, /).\r\n     * <p>\r\n     * Multiplication (*) and division (/) have higher precedence than\r\n     * addition (+) and subtraction (-).  Among operations within the same\r\n     * level of precedence, grouping is from left to right.\r\n     * <p>\r\n     * This algorithm follows the algorithm described in Weiss, pages 105-108.\r\n     */\r\n    Stack<Token> getFormula(String formula) {\r\n        Stack<Token> returnStack = new Stack<>();  // stack of Tokens (representing a postfix expression)\r\n        boolean error = false;\r\n        char ch = ' ';\r\n        \r\n        int literalValue;\r\n        \r\n        int index = 0;  // index into formula\r\n        Stack<Token> operatorStack = new Stack<>();  // stack of operators\r\n        \r\n        while (index < formula.length()) {\r\n            // get rid of leading whitespace characters\r\n            while (index < formula.length()) {\r\n                ch = formula.charAt(index);\r\n                if (!Character.isWhitespace(ch)) {\r\n                    break;\r\n                }\r\n                index++;\r\n            }\r\n            \r\n            if (index == formula.length()) {\r\n                error = true;\r\n                break;\r\n            }\r\n            \r\n            // ASSERT: ch now contains the first character of the next token.\r\n            if (isOperator(ch)) {\r\n                // We found an operator token\r\n                switch (ch) {\r\n                    case OperatorToken.Plus, OperatorToken.Minus, OperatorToken.Mult, OperatorToken.Div, OperatorToken.LeftParen -> {\r\n                        // push operatorTokens onto the output stack until\r\n                        // we reach an operator on the operator stack that has\r\n                        // lower priority than the current one.\r\n                        OperatorToken stackOperator;\r\n                        while (!operatorStack.isEmpty()) {\r\n                            stackOperator = (OperatorToken) operatorStack.peek();\r\n                            if ((stackOperator.priority() >= operatorPriority(ch)) &&\r\n                                    (stackOperator.getOperatorToken() != OperatorToken.LeftParen)) {\r\n                    \r\n                                // output the operator to the return stack\r\n                                operatorStack.pop();\r\n                                returnStack.push(stackOperator);\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    default -> {\r\n                        // This case should NEVER happen\r\n                        System.out.println(\"Error in getFormula.\");\r\n                        System.exit(0);\r\n                    }\r\n                }\r\n                // push the operator on the operator stack\r\n                operatorStack.push(new OperatorToken(ch));\r\n                \r\n                index++;\r\n                \r\n            } else if (ch == ')') {    // maybe define OperatorToken.RightParen ?\r\n                OperatorToken stackOperator;\r\n                stackOperator = (OperatorToken) operatorStack.pop();\r\n                // This code does not handle operatorStack underflow.\r\n                while (stackOperator.getOperatorToken() != OperatorToken.LeftParen) {\r\n                    // pop operators off the stack until a LeftParen appears and\r\n                    // place the operators on the output stack\r\n                    returnStack.push(stackOperator);\r\n                    stackOperator = (OperatorToken) operatorStack.pop();\r\n                }\r\n                \r\n                index++;\r\n            } else if (Character.isDigit(ch)) {\r\n                // We found a literal token\r\n                literalValue = ch - '0';\r\n                index++;\r\n                while (index < formula.length()) {\r\n                    ch = formula.charAt(index);\r\n                    if (Character.isDigit(ch)) {\r\n                        literalValue = (literalValue * 10) + (ch - '0');\r\n                        index++;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // place the literal on the output stack\r\n                returnStack.push(new LiteralToken(literalValue));\r\n                \r\n            } else if (Character.isUpperCase(ch)) {\r\n                // We found a cell reference token\r\n                CellToken cellToken = new CellToken();\r\n                index = getCellToken(formula, index, cellToken);\r\n                if (cellToken.getRow() == BAD_CELL) {\r\n                    error = true;\r\n                    break;\r\n                } else {\r\n                    // place the cell reference on the output stack\r\n                    returnStack.push(cellToken);\r\n                }\r\n                \r\n            } else {\r\n                error = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // pop all remaining operators off the operator stack\r\n        while (!operatorStack.isEmpty()) {\r\n            returnStack.push(operatorStack.pop());\r\n        }\r\n        \r\n        if (error) {\r\n            // a parse error; return the empty stack\r\n            returnStack.clear();\r\n        }\r\n        \r\n        return returnStack;\r\n    }\r\n    /**\r\n     * Return true if the char ch is an operator of a formula.\r\n     * Current operators are: +, -, *, /, (.\r\n     *\r\n     * @param ch a char\r\n     * @return whether ch is an operator\r\n     */\r\n    boolean isOperator(char ch) {\r\n        return ((ch == OperatorToken.Plus) ||\r\n                (ch == OperatorToken.Minus) ||\r\n                (ch == OperatorToken.Mult) ||\r\n                (ch == OperatorToken.Div) ||\r\n                (ch == OperatorToken.LeftParen));\r\n    }\r\n    \r\n    /**\r\n     * Given an operator, return its priority.\r\n     * <p>\r\n     * priorities:\r\n     * +, - : 0\r\n     * *, / : 1\r\n     * (    : 2\r\n     *\r\n     * @param ch a char\r\n     * @return the priority of the operator\r\n     */\r\n    int operatorPriority(char ch) {\r\n        if (!isOperator(ch)) {\r\n            // This case should NEVER happen\r\n            System.out.println(\"Error in operatorPriority.\");\r\n            System.exit(0);\r\n        }\r\n        switch (ch) {\r\n            case OperatorToken.Plus, OperatorToken.Minus -> {\r\n                return 0;\r\n            }\r\n            case OperatorToken.Mult, OperatorToken.Div -> {\r\n                return 1;\r\n            }\r\n            case OperatorToken.LeftParen -> {\r\n                return 2;\r\n            }\r\n            default -> {\r\n                // This case should NEVER happen\r\n                System.out.println(\"Error in operatorPriority.\");\r\n                System.exit(0);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/Cell.java b/model/Cell.java
--- a/model/Cell.java	
+++ b/model/Cell.java	
@@ -1,20 +1,36 @@
+/**
+ * @author Bairu Li
+ * @author Andy Comfort
+ */
 package model;
 
 import java.util.HashSet;
 import java.util.Set;
 import java.util.Stack;
 
+/**
+ * Represents a single cell in a spreadsheet
+ */
 public class Cell {
     
+    /** A constant for invalid cell references. */
     private static final int BAD_CELL = -1;
+    
+    /** The formula of the cell. */
     private String formula;
+    
+    /** The value of the cell. */
     private int value;
-    // the expression tree below represents the formula
+    
+    /** The formula stored as an expression tree. */
     private final ExpressionTree expressionTree;
     
-    // other cells that "points" to this cell
+    /** The set of cells that reference this cell. */
     private final Set<Cell> references;
     
+    /**
+     * Instantiates a new Cell.
+     */
     public Cell() {
         formula = "";
         value = 0;
@@ -22,40 +38,92 @@
         references = new HashSet<>();
     }
     
+    /**
+     * Evaluates the cell's expression tree and sets
+     * value equal to the result.
+     *
+     * @param spreadsheet the spreadsheet
+     */
     public void evaluate(Spreadsheet spreadsheet) {
     	value = expressionTree.evaluate(spreadsheet);
     }
     
+    /**
+     * Gets the cell formula.
+     *
+     * @return the formula
+     */
     public String getFormula() {
         return formula;
     }
     
+    /**
+     * Gets the cell value.
+     *
+     * @return the value
+     */
     public int getValue() {
     	return value;
     }
     
+    /**
+     * Has formula returns true if the cell's formula
+     * has been set.
+     *
+     * @return true, if a formula has been set
+     */
     public boolean hasFormula() { return !formula.equals(""); }
     
+    /**
+     * Adds a cell that references this cell.
+     *
+     * @param c the cell to be added
+     */
     public void addReferences(Cell c) {
     	references.add(c);
     }
     
+    /**
+     * Remove a cell that references this cell.
+     *
+     * @param c the cell to be removed
+     */
     public void removeReferences(Cell c) {
     	references.remove(c);
     }
     
+    /**
+     * Gets the set of references as an array.
+     *
+     * @return the cell references as an array
+     */
     public Cell[] getReferences() {
     	return references.toArray(new Cell[0]);
     }
     
+    /**
+     * Gets the indegrees of this cell.
+     *
+     * @return the indegrees
+     */
     public int getIndegrees() {
     	return references.size();
     }
-    // gets the cells that this cell points to
+    
+    /**
+     * Gets the cell references that this cell points to.
+     *
+     * @return an array of CellTokens this cell points to
+     */
     public CellToken[] getDependents() {
     	return expressionTree.getDependents().toArray(new CellToken[0]);
     }
     
+    /**
+     * Sets the formula of this cell.
+     *
+     * @param s the new formula to be set
+     */
     public void setFormula(String s) {
     	expressionTree.BuildExpressionTree(getFormula(s));
     	formula = s;
@@ -192,6 +260,9 @@
      * level of precedence, grouping is from left to right.
      * <p>
      * This algorithm follows the algorithm described in Weiss, pages 105-108.
+     *
+     * @param formula the formula
+     * @return the formula
      */
     Stack<Token> getFormula(String formula) {
         Stack<Token> returnStack = new Stack<>();  // stack of Tokens (representing a postfix expression)
@@ -309,6 +380,7 @@
         
         return returnStack;
     }
+    
     /**
      * Return true if the char ch is an operator of a formula.
      * Current operators are: +, -, *, /, (.
Index: model/Token.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\npublic class Token {\r\n    private final String type;\r\n    \r\n    public Token(String type) {\r\n        this.type = type;\r\n    }\r\n    \r\n    public String getType() {\r\n        return type;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/Token.java b/model/Token.java
--- a/model/Token.java	
+++ b/model/Token.java	
@@ -1,12 +1,31 @@
+/**
+ * @author Andy Comfort
+ */
 package model;
 
+/**
+ * Represents a general token that can either
+ * be a CellToken, OperatorToken, or LiteralToken.
+ */
 public class Token {
+    
+    /** The type of this token. */
     private final String type;
     
+    /**
+     * Instantiates a new Token.
+     *
+     * @param type the type
+     */
     public Token(String type) {
         this.type = type;
     }
     
+    /**
+     * Gets the type of token.
+     *
+     * @return the type
+     */
     public String getType() {
         return type;
     }
